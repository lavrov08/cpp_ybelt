<div><h2>Введение</h2><p>В курсе «Белый пояс по С++» <a href="https://www.coursera.org/learn/c-plus-plus-white/programming/sO7Vq/final-naia-zadacha-kursa" target="_blank" rel="noopener">финальным заданием</a> была разработка базы данных, которая работала с парами (<em>дата</em>, <em>событие</em>). В этой задаче вам нужно развить эту базу данных, научив её выбирать и удалять события, удовлетворяющие заданному условию, а также разделив её код на несколько файлов.</p><p>Более подробно, ваша программа должна уметь обрабатывать набор команд:</p><ul><li><strong>Add <em>date</em> <em>event</em></strong> — добавить в базу данных пару (<em><strong>date</strong></em>, <em><strong>event</strong></em>);</li><li><strong>Print</strong> — вывести всё содержимое базы данных;</li><li><strong>Find <em>condition</em></strong> — вывести все записи, содержащиеся в базе данных, которые удовлетворяют условию <em><strong>condition</strong></em>;</li><li><strong>Del <em>condition</em></strong> — удалить из базы все записи, которые удовлетворяют условию <em><strong>condition</strong></em>;</li><li><strong>Last <em>date</em></strong> — вывести запись с последним событием, случившимся не позже данной даты.</li></ul><p>Условия в командах <strong>Find</strong> и <strong>Del</strong> накладывают определённые ограничения на даты и события, например:</p><ul><li><strong>Find date &lt; 2017-11-06</strong> — найти все события, которые случились раньше 6 ноября 2017 года;</li><li><strong>Del event != "holiday"</strong> — удалить из базы все события, кроме «<strong>holiday</strong>»;</li><li><strong>Find date &gt;= 2017-01-01 AND date &lt; 2017-07-01 AND event == "sport event"</strong> — найти всё события «<strong>sport event</strong>», случившиеся в первой половине 2017 года;</li><li><strong>Del date &lt; 2017-01-01 AND (event == "holiday" OR event == "sport event")</strong> — удалить из базы все события «<strong>holiday</strong>» и «<strong>sport event</strong>», случившиеся до 2017 года.</li></ul><p>В командах обоих типов условия могут быть пустыми: под такое условие попадают все события.</p><h2>Структура программы</h2><p>Ниже вам даны заготовки для файлов</p><ul><li>condition_parser.h/cpp — в видеолекции «Задача разбора арифметического выражения. Описание решения» мы продемонстрировали построение абстрактного синтаксического дерева для арифметических выражений. Реализация этого алгоритма для разбора условий в командах <strong>Find</strong> и <strong>Del </strong>содержится в функции ParseCondition, объявленной и полностью реализованной в файлах condition_parser.h/cpp;</li></ul><ul><li>token.h/cpp — содержат готовый токенизатор, который используется в функции ParseCondition;</li><li>main.cpp — содержит готовую функцию main.</li></ul><p>Вам нужно проанализировать выданный код и разработать недостающие классы и функции:</p><ul><li>класс Database, который представляет собой базу данных, — вы должны сами создать его публичный интерфейс, основываясь на том, как он используется в функции main;</li><li>классы Node, EmptyNode, DateComparisonNode, EventComparisonNode и LogicalOperationNode — сформировать их иерархию и публичный интерфейс вам поможет анализ функций main и ParseCondition;</li><li>класс Date, а также функцию ParseDate и оператор вывода в поток для класса Date.</li></ul><p>На проверку вы должны прислать архив, состоящий из файлов:</p><ul><li>date.h/cpp — эти файлы должны содержать объявления и определения класса Date, функции ParseDate и оператора вывода в поток для класса Date;</li><li>database.h/cpp — эти файлы должны содержать объявление и определение класса Database;</li><li>node.h/cpp — эти файлы должны содержать объявления и определения класса Node, а также всех его потомков (см. выше), которые представляют собой узлы абстрактного синтаксического дерева, формируемого функцией ParseCondition;</li><li>condition_parser.h/cpp;</li><li>token.h/cpp;</li><li>main.cpp;</li><li>другие .h- и .cpp-файлы, которые вы посчитаете нужным создать в своём решении.</li></ul><h2>Как будет тестироваться ваше решение</h2><p>Тестирование вашего решения будет выполняться в два этапа. На первом этапе автоматическая тестирующая система распакует присланный вами архив и соберёт извлечённые файлы в исполняемый файл. Затем этот исполняемый файл будет запущен на наборе тестов. Тестирование выполняется так же, как и для большинства задач на нашем курсе — тест подаётся в stdin, замеряется время выполнения программы, а затем анализируется stdout.</p><p>На втором этапе будет выполняться тестирование отдельных файлов вашего проекта. Проверяется, что файл date.h действительно содержит объявление класса Date, что Database::FindIf корректно выполняет поиск по переданному предикату и т.д. Мы ожидаем от ваших классов интерфейс, который зафиксирован в функции main. Поэтому в классах Database и Node делайте у методов именно те сигнатуры, которые используются в функции main.</p><h2>Формат ввода и вывода</h2><p>В стандартном вводе содержатся команды для работы с базой данных, по одной команде в строке. Ваша программа должна считать их и вывести результаты обработки в стандартный вывод. Правила обработки команд приведены ниже.</p>
  <h3>Команда Add</h3><p>Встретив команду <strong>Add <em>date</em> <em>event</em></strong>, ваша программа должна добавить пару (<em><strong>date</strong></em>, <em><strong>event</strong></em>) в базу данных и затем показывать её при поиске (команда <strong>Find</strong>) или печати (команда <strong>Print</strong>). Одинаковые события, произошедшие в один и тот же день, сохранять не нужно: добавление в базу уже существующей пары (<em><strong>date</strong></em>, <em><strong>event</strong></em>) должно игнорироваться. В одну и ту же дату может произойти много разных событий, БД должна суметь их все сохранить.</p><p>Гарантируется, что поле <em><strong>date</strong></em> в команде <strong>Add</strong> имеет формат «<em>Год</em>-<em>Месяц</em>-<em>День</em>», где <em>Год</em> — это целое число от 0 до 9999, <em>Месяц</em> — это номер месяца от 1 до 12 включительно, <em>День</em> — это номер дня от 1 до 31 включительно. После даты обязательно следует пробел, отделяющий её от события. Примеры корректных дат: <strong>2017-11-07</strong>, <strong>0-2-31</strong>.</p><p>Вся остальная часть строки в команде <strong>Add</strong> задаёт событие. Оно может содержать пробелы, поэтому для его считывания удобно воспользоваться функцией getline. При этом гарантируется, что название события не может содержать символ кавычки (<strong>"</strong>). Таким образом, этот символ может встретиться лишь в условии в командах <strong>Find</strong> и <strong>Del</strong>, являясь ограничителем названия события.</p><p>Пример</p><p>Для команды <strong>Add 2017-11-07 big sport event</strong> программа должна добавить в базу данных пару (<strong>2017-11-07</strong>, <strong>big sport event</strong>).</p>
  <h3>Команда Del</h3><p>Встретив команду <strong>Del <em>condition</em></strong>, ваша программа должна удалить из базы данных все события, удовлетворяющие условию <em><strong>condition</strong></em>, и вывести в стандартный вывод количество удалённых записей <em><strong>N</strong></em> в формате «<strong>Removed <em>N </em>entries</strong>». Если условие пусто, результатом выполнения команды должна стать очистка всей базы данных.</p>
</pre><h3>Команда Print</h3><p>Встретив команду <strong>Print</strong>, ваша программа должна вывести все пары (<em>дата</em>, <em>событие</em>), которые в данный момент содержатся в базе данных. Пары надо выводить по одной в строке. Они должны быть отсортированы по дате по возрастанию. События в рамках одной даты необходимо выводить в порядке добавления (за исключением уже удалённых и попыток добавления повторов).</p><p>Даты надо выводить в формате <strong>ГГГГ-ММ-ДД</strong>, где Г, М, Д — это цифры чисел года, месяца и дня соответственно. Если какое-то число имеет меньше разрядов, чем нужно, его надо дополнить нулями, например: <strong>0001-01-01</strong> — первое января первого года.</p>
<h3>Команда Find</h3><p>Встретив команду <strong>Find <em>condition</em></strong>, ваша программа должна вывести все пары (<em>дата</em>, <em>событие</em>), которые в данный момент содержатся в базе данных и удовлетворяют условию <em><strong>condition</strong></em>. Формат вывода аналогичен команде <strong>Print</strong>. Поиск с пустым условием эквивалентен команде <strong>Print</strong>. В конце команда должна вывести строку <strong>Found <em>N</em> entries</strong>, где <em><strong>N</strong></em>— количество найденных пар.</p>

<h3>Команда Last</h3><p>По команде <strong>Last <em>date</em></strong> нужно вывести последнее из событий, случившихся к дате <em><strong>date</strong></em>. Более формально:</p><ul><li>среди всех имеющихся дат событий нужно найти наибольшую, не превосходящую <em><strong>date</strong></em>;</li><li>из всех событий с такой датой нужно выбрать <strong>последнее добавленное</strong> и вывести в формате, аналогичном формату команды <strong>Print</strong>;</li><li>если <em><strong>date</strong></em> меньше всех имеющихся дат, необходимо вывести «<strong>No entries</strong>».</li></ul>
<p>Обратите внимание, что в файле main.cpp мы используем наш фреймворк юнит-тестов, для тестирования функций ParseCondition и ParseEvent. В процессе работы над проектом вы можете разрабатывать свои тесты и добавлять их в функцию TestAll.
